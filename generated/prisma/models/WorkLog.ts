
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/*
 * This file exports the `WorkLog` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model WorkLog
 * 
 */
export type WorkLogModel = runtime.Types.Result.DefaultSelection<Prisma.$WorkLogPayload>

export type AggregateWorkLog = {
  _count: WorkLogCountAggregateOutputType | null
  _avg: WorkLogAvgAggregateOutputType | null
  _sum: WorkLogSumAggregateOutputType | null
  _min: WorkLogMinAggregateOutputType | null
  _max: WorkLogMaxAggregateOutputType | null
}

export type WorkLogAvgAggregateOutputType = {
  LogID: number | null
  EmployeeID: number | null
  TemplateID: number | null
  TotalWorkedHours: runtime.Decimal | null
}

export type WorkLogSumAggregateOutputType = {
  LogID: number | null
  EmployeeID: number | null
  TemplateID: number | null
  TotalWorkedHours: runtime.Decimal | null
}

export type WorkLogMinAggregateOutputType = {
  LogID: number | null
  EmployeeID: number | null
  TemplateID: number | null
  WorkDate: Date | null
  LoginTime: Date | null
  LogoutTime: Date | null
  TotalWorkedHours: runtime.Decimal | null
}

export type WorkLogMaxAggregateOutputType = {
  LogID: number | null
  EmployeeID: number | null
  TemplateID: number | null
  WorkDate: Date | null
  LoginTime: Date | null
  LogoutTime: Date | null
  TotalWorkedHours: runtime.Decimal | null
}

export type WorkLogCountAggregateOutputType = {
  LogID: number
  EmployeeID: number
  TemplateID: number
  WorkDate: number
  LoginTime: number
  LogoutTime: number
  TotalWorkedHours: number
  _all: number
}


export type WorkLogAvgAggregateInputType = {
  LogID?: true
  EmployeeID?: true
  TemplateID?: true
  TotalWorkedHours?: true
}

export type WorkLogSumAggregateInputType = {
  LogID?: true
  EmployeeID?: true
  TemplateID?: true
  TotalWorkedHours?: true
}

export type WorkLogMinAggregateInputType = {
  LogID?: true
  EmployeeID?: true
  TemplateID?: true
  WorkDate?: true
  LoginTime?: true
  LogoutTime?: true
  TotalWorkedHours?: true
}

export type WorkLogMaxAggregateInputType = {
  LogID?: true
  EmployeeID?: true
  TemplateID?: true
  WorkDate?: true
  LoginTime?: true
  LogoutTime?: true
  TotalWorkedHours?: true
}

export type WorkLogCountAggregateInputType = {
  LogID?: true
  EmployeeID?: true
  TemplateID?: true
  WorkDate?: true
  LoginTime?: true
  LogoutTime?: true
  TotalWorkedHours?: true
  _all?: true
}

export type WorkLogAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which WorkLog to aggregate.
   */
  where?: Prisma.WorkLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of WorkLogs to fetch.
   */
  orderBy?: Prisma.WorkLogOrderByWithRelationInput | Prisma.WorkLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.WorkLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` WorkLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` WorkLogs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned WorkLogs
  **/
  _count?: true | WorkLogCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: WorkLogAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: WorkLogSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: WorkLogMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: WorkLogMaxAggregateInputType
}

export type GetWorkLogAggregateType<T extends WorkLogAggregateArgs> = {
      [P in keyof T & keyof AggregateWorkLog]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateWorkLog[P]>
    : Prisma.GetScalarType<T[P], AggregateWorkLog[P]>
}




export type WorkLogGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.WorkLogWhereInput
  orderBy?: Prisma.WorkLogOrderByWithAggregationInput | Prisma.WorkLogOrderByWithAggregationInput[]
  by: Prisma.WorkLogScalarFieldEnum[] | Prisma.WorkLogScalarFieldEnum
  having?: Prisma.WorkLogScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: WorkLogCountAggregateInputType | true
  _avg?: WorkLogAvgAggregateInputType
  _sum?: WorkLogSumAggregateInputType
  _min?: WorkLogMinAggregateInputType
  _max?: WorkLogMaxAggregateInputType
}

export type WorkLogGroupByOutputType = {
  LogID: number
  EmployeeID: number
  TemplateID: number | null
  WorkDate: Date | null
  LoginTime: Date | null
  LogoutTime: Date | null
  TotalWorkedHours: runtime.Decimal | null
  _count: WorkLogCountAggregateOutputType | null
  _avg: WorkLogAvgAggregateOutputType | null
  _sum: WorkLogSumAggregateOutputType | null
  _min: WorkLogMinAggregateOutputType | null
  _max: WorkLogMaxAggregateOutputType | null
}

type GetWorkLogGroupByPayload<T extends WorkLogGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<WorkLogGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof WorkLogGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], WorkLogGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], WorkLogGroupByOutputType[P]>
      }
    >
  >



export type WorkLogWhereInput = {
  AND?: Prisma.WorkLogWhereInput | Prisma.WorkLogWhereInput[]
  OR?: Prisma.WorkLogWhereInput[]
  NOT?: Prisma.WorkLogWhereInput | Prisma.WorkLogWhereInput[]
  LogID?: Prisma.IntFilter<"WorkLog"> | number
  EmployeeID?: Prisma.IntFilter<"WorkLog"> | number
  TemplateID?: Prisma.IntNullableFilter<"WorkLog"> | number | null
  WorkDate?: Prisma.DateTimeNullableFilter<"WorkLog"> | Date | string | null
  LoginTime?: Prisma.DateTimeNullableFilter<"WorkLog"> | Date | string | null
  LogoutTime?: Prisma.DateTimeNullableFilter<"WorkLog"> | Date | string | null
  TotalWorkedHours?: Prisma.DecimalNullableFilter<"WorkLog"> | runtime.Decimal | runtime.DecimalJsLike | number | string | null
  Employee?: Prisma.XOR<Prisma.EmployeeScalarRelationFilter, Prisma.EmployeeWhereInput>
  WorkTemplate?: Prisma.XOR<Prisma.WorkTemplateNullableScalarRelationFilter, Prisma.WorkTemplateWhereInput> | null
}

export type WorkLogOrderByWithRelationInput = {
  LogID?: Prisma.SortOrder
  EmployeeID?: Prisma.SortOrder
  TemplateID?: Prisma.SortOrderInput | Prisma.SortOrder
  WorkDate?: Prisma.SortOrderInput | Prisma.SortOrder
  LoginTime?: Prisma.SortOrderInput | Prisma.SortOrder
  LogoutTime?: Prisma.SortOrderInput | Prisma.SortOrder
  TotalWorkedHours?: Prisma.SortOrderInput | Prisma.SortOrder
  Employee?: Prisma.EmployeeOrderByWithRelationInput
  WorkTemplate?: Prisma.WorkTemplateOrderByWithRelationInput
}

export type WorkLogWhereUniqueInput = Prisma.AtLeast<{
  LogID?: number
  AND?: Prisma.WorkLogWhereInput | Prisma.WorkLogWhereInput[]
  OR?: Prisma.WorkLogWhereInput[]
  NOT?: Prisma.WorkLogWhereInput | Prisma.WorkLogWhereInput[]
  EmployeeID?: Prisma.IntFilter<"WorkLog"> | number
  TemplateID?: Prisma.IntNullableFilter<"WorkLog"> | number | null
  WorkDate?: Prisma.DateTimeNullableFilter<"WorkLog"> | Date | string | null
  LoginTime?: Prisma.DateTimeNullableFilter<"WorkLog"> | Date | string | null
  LogoutTime?: Prisma.DateTimeNullableFilter<"WorkLog"> | Date | string | null
  TotalWorkedHours?: Prisma.DecimalNullableFilter<"WorkLog"> | runtime.Decimal | runtime.DecimalJsLike | number | string | null
  Employee?: Prisma.XOR<Prisma.EmployeeScalarRelationFilter, Prisma.EmployeeWhereInput>
  WorkTemplate?: Prisma.XOR<Prisma.WorkTemplateNullableScalarRelationFilter, Prisma.WorkTemplateWhereInput> | null
}, "LogID">

export type WorkLogOrderByWithAggregationInput = {
  LogID?: Prisma.SortOrder
  EmployeeID?: Prisma.SortOrder
  TemplateID?: Prisma.SortOrderInput | Prisma.SortOrder
  WorkDate?: Prisma.SortOrderInput | Prisma.SortOrder
  LoginTime?: Prisma.SortOrderInput | Prisma.SortOrder
  LogoutTime?: Prisma.SortOrderInput | Prisma.SortOrder
  TotalWorkedHours?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.WorkLogCountOrderByAggregateInput
  _avg?: Prisma.WorkLogAvgOrderByAggregateInput
  _max?: Prisma.WorkLogMaxOrderByAggregateInput
  _min?: Prisma.WorkLogMinOrderByAggregateInput
  _sum?: Prisma.WorkLogSumOrderByAggregateInput
}

export type WorkLogScalarWhereWithAggregatesInput = {
  AND?: Prisma.WorkLogScalarWhereWithAggregatesInput | Prisma.WorkLogScalarWhereWithAggregatesInput[]
  OR?: Prisma.WorkLogScalarWhereWithAggregatesInput[]
  NOT?: Prisma.WorkLogScalarWhereWithAggregatesInput | Prisma.WorkLogScalarWhereWithAggregatesInput[]
  LogID?: Prisma.IntWithAggregatesFilter<"WorkLog"> | number
  EmployeeID?: Prisma.IntWithAggregatesFilter<"WorkLog"> | number
  TemplateID?: Prisma.IntNullableWithAggregatesFilter<"WorkLog"> | number | null
  WorkDate?: Prisma.DateTimeNullableWithAggregatesFilter<"WorkLog"> | Date | string | null
  LoginTime?: Prisma.DateTimeNullableWithAggregatesFilter<"WorkLog"> | Date | string | null
  LogoutTime?: Prisma.DateTimeNullableWithAggregatesFilter<"WorkLog"> | Date | string | null
  TotalWorkedHours?: Prisma.DecimalNullableWithAggregatesFilter<"WorkLog"> | runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogCreateInput = {
  WorkDate?: Date | string | null
  LoginTime?: Date | string | null
  LogoutTime?: Date | string | null
  TotalWorkedHours?: runtime.Decimal | runtime.DecimalJsLike | number | string | null
  Employee: Prisma.EmployeeCreateNestedOneWithoutWorkLogInput
  WorkTemplate?: Prisma.WorkTemplateCreateNestedOneWithoutWorkLogInput
}

export type WorkLogUncheckedCreateInput = {
  LogID?: number
  EmployeeID: number
  TemplateID?: number | null
  WorkDate?: Date | string | null
  LoginTime?: Date | string | null
  LogoutTime?: Date | string | null
  TotalWorkedHours?: runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogUpdateInput = {
  WorkDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LoginTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LogoutTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  TotalWorkedHours?: Prisma.NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null
  Employee?: Prisma.EmployeeUpdateOneRequiredWithoutWorkLogNestedInput
  WorkTemplate?: Prisma.WorkTemplateUpdateOneWithoutWorkLogNestedInput
}

export type WorkLogUncheckedUpdateInput = {
  LogID?: Prisma.IntFieldUpdateOperationsInput | number
  EmployeeID?: Prisma.IntFieldUpdateOperationsInput | number
  TemplateID?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  WorkDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LoginTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LogoutTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  TotalWorkedHours?: Prisma.NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogCreateManyInput = {
  EmployeeID: number
  TemplateID?: number | null
  WorkDate?: Date | string | null
  LoginTime?: Date | string | null
  LogoutTime?: Date | string | null
  TotalWorkedHours?: runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogUpdateManyMutationInput = {
  WorkDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LoginTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LogoutTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  TotalWorkedHours?: Prisma.NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogUncheckedUpdateManyInput = {
  LogID?: Prisma.IntFieldUpdateOperationsInput | number
  EmployeeID?: Prisma.IntFieldUpdateOperationsInput | number
  TemplateID?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  WorkDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LoginTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LogoutTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  TotalWorkedHours?: Prisma.NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogListRelationFilter = {
  every?: Prisma.WorkLogWhereInput
  some?: Prisma.WorkLogWhereInput
  none?: Prisma.WorkLogWhereInput
}

export type WorkLogOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type WorkLogCountOrderByAggregateInput = {
  LogID?: Prisma.SortOrder
  EmployeeID?: Prisma.SortOrder
  TemplateID?: Prisma.SortOrder
  WorkDate?: Prisma.SortOrder
  LoginTime?: Prisma.SortOrder
  LogoutTime?: Prisma.SortOrder
  TotalWorkedHours?: Prisma.SortOrder
}

export type WorkLogAvgOrderByAggregateInput = {
  LogID?: Prisma.SortOrder
  EmployeeID?: Prisma.SortOrder
  TemplateID?: Prisma.SortOrder
  TotalWorkedHours?: Prisma.SortOrder
}

export type WorkLogMaxOrderByAggregateInput = {
  LogID?: Prisma.SortOrder
  EmployeeID?: Prisma.SortOrder
  TemplateID?: Prisma.SortOrder
  WorkDate?: Prisma.SortOrder
  LoginTime?: Prisma.SortOrder
  LogoutTime?: Prisma.SortOrder
  TotalWorkedHours?: Prisma.SortOrder
}

export type WorkLogMinOrderByAggregateInput = {
  LogID?: Prisma.SortOrder
  EmployeeID?: Prisma.SortOrder
  TemplateID?: Prisma.SortOrder
  WorkDate?: Prisma.SortOrder
  LoginTime?: Prisma.SortOrder
  LogoutTime?: Prisma.SortOrder
  TotalWorkedHours?: Prisma.SortOrder
}

export type WorkLogSumOrderByAggregateInput = {
  LogID?: Prisma.SortOrder
  EmployeeID?: Prisma.SortOrder
  TemplateID?: Prisma.SortOrder
  TotalWorkedHours?: Prisma.SortOrder
}

export type WorkLogCreateNestedManyWithoutEmployeeInput = {
  create?: Prisma.XOR<Prisma.WorkLogCreateWithoutEmployeeInput, Prisma.WorkLogUncheckedCreateWithoutEmployeeInput> | Prisma.WorkLogCreateWithoutEmployeeInput[] | Prisma.WorkLogUncheckedCreateWithoutEmployeeInput[]
  connectOrCreate?: Prisma.WorkLogCreateOrConnectWithoutEmployeeInput | Prisma.WorkLogCreateOrConnectWithoutEmployeeInput[]
  createMany?: Prisma.WorkLogCreateManyEmployeeInputEnvelope
  connect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
}

export type WorkLogUncheckedCreateNestedManyWithoutEmployeeInput = {
  create?: Prisma.XOR<Prisma.WorkLogCreateWithoutEmployeeInput, Prisma.WorkLogUncheckedCreateWithoutEmployeeInput> | Prisma.WorkLogCreateWithoutEmployeeInput[] | Prisma.WorkLogUncheckedCreateWithoutEmployeeInput[]
  connectOrCreate?: Prisma.WorkLogCreateOrConnectWithoutEmployeeInput | Prisma.WorkLogCreateOrConnectWithoutEmployeeInput[]
  createMany?: Prisma.WorkLogCreateManyEmployeeInputEnvelope
  connect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
}

export type WorkLogUpdateManyWithoutEmployeeNestedInput = {
  create?: Prisma.XOR<Prisma.WorkLogCreateWithoutEmployeeInput, Prisma.WorkLogUncheckedCreateWithoutEmployeeInput> | Prisma.WorkLogCreateWithoutEmployeeInput[] | Prisma.WorkLogUncheckedCreateWithoutEmployeeInput[]
  connectOrCreate?: Prisma.WorkLogCreateOrConnectWithoutEmployeeInput | Prisma.WorkLogCreateOrConnectWithoutEmployeeInput[]
  upsert?: Prisma.WorkLogUpsertWithWhereUniqueWithoutEmployeeInput | Prisma.WorkLogUpsertWithWhereUniqueWithoutEmployeeInput[]
  createMany?: Prisma.WorkLogCreateManyEmployeeInputEnvelope
  set?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  disconnect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  delete?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  connect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  update?: Prisma.WorkLogUpdateWithWhereUniqueWithoutEmployeeInput | Prisma.WorkLogUpdateWithWhereUniqueWithoutEmployeeInput[]
  updateMany?: Prisma.WorkLogUpdateManyWithWhereWithoutEmployeeInput | Prisma.WorkLogUpdateManyWithWhereWithoutEmployeeInput[]
  deleteMany?: Prisma.WorkLogScalarWhereInput | Prisma.WorkLogScalarWhereInput[]
}

export type WorkLogUncheckedUpdateManyWithoutEmployeeNestedInput = {
  create?: Prisma.XOR<Prisma.WorkLogCreateWithoutEmployeeInput, Prisma.WorkLogUncheckedCreateWithoutEmployeeInput> | Prisma.WorkLogCreateWithoutEmployeeInput[] | Prisma.WorkLogUncheckedCreateWithoutEmployeeInput[]
  connectOrCreate?: Prisma.WorkLogCreateOrConnectWithoutEmployeeInput | Prisma.WorkLogCreateOrConnectWithoutEmployeeInput[]
  upsert?: Prisma.WorkLogUpsertWithWhereUniqueWithoutEmployeeInput | Prisma.WorkLogUpsertWithWhereUniqueWithoutEmployeeInput[]
  createMany?: Prisma.WorkLogCreateManyEmployeeInputEnvelope
  set?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  disconnect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  delete?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  connect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  update?: Prisma.WorkLogUpdateWithWhereUniqueWithoutEmployeeInput | Prisma.WorkLogUpdateWithWhereUniqueWithoutEmployeeInput[]
  updateMany?: Prisma.WorkLogUpdateManyWithWhereWithoutEmployeeInput | Prisma.WorkLogUpdateManyWithWhereWithoutEmployeeInput[]
  deleteMany?: Prisma.WorkLogScalarWhereInput | Prisma.WorkLogScalarWhereInput[]
}

export type NullableDecimalFieldUpdateOperationsInput = {
  set?: runtime.Decimal | runtime.DecimalJsLike | number | string | null
  increment?: runtime.Decimal | runtime.DecimalJsLike | number | string
  decrement?: runtime.Decimal | runtime.DecimalJsLike | number | string
  multiply?: runtime.Decimal | runtime.DecimalJsLike | number | string
  divide?: runtime.Decimal | runtime.DecimalJsLike | number | string
}

export type NullableIntFieldUpdateOperationsInput = {
  set?: number | null
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type WorkLogCreateNestedManyWithoutWorkTemplateInput = {
  create?: Prisma.XOR<Prisma.WorkLogCreateWithoutWorkTemplateInput, Prisma.WorkLogUncheckedCreateWithoutWorkTemplateInput> | Prisma.WorkLogCreateWithoutWorkTemplateInput[] | Prisma.WorkLogUncheckedCreateWithoutWorkTemplateInput[]
  connectOrCreate?: Prisma.WorkLogCreateOrConnectWithoutWorkTemplateInput | Prisma.WorkLogCreateOrConnectWithoutWorkTemplateInput[]
  createMany?: Prisma.WorkLogCreateManyWorkTemplateInputEnvelope
  connect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
}

export type WorkLogUncheckedCreateNestedManyWithoutWorkTemplateInput = {
  create?: Prisma.XOR<Prisma.WorkLogCreateWithoutWorkTemplateInput, Prisma.WorkLogUncheckedCreateWithoutWorkTemplateInput> | Prisma.WorkLogCreateWithoutWorkTemplateInput[] | Prisma.WorkLogUncheckedCreateWithoutWorkTemplateInput[]
  connectOrCreate?: Prisma.WorkLogCreateOrConnectWithoutWorkTemplateInput | Prisma.WorkLogCreateOrConnectWithoutWorkTemplateInput[]
  createMany?: Prisma.WorkLogCreateManyWorkTemplateInputEnvelope
  connect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
}

export type WorkLogUpdateManyWithoutWorkTemplateNestedInput = {
  create?: Prisma.XOR<Prisma.WorkLogCreateWithoutWorkTemplateInput, Prisma.WorkLogUncheckedCreateWithoutWorkTemplateInput> | Prisma.WorkLogCreateWithoutWorkTemplateInput[] | Prisma.WorkLogUncheckedCreateWithoutWorkTemplateInput[]
  connectOrCreate?: Prisma.WorkLogCreateOrConnectWithoutWorkTemplateInput | Prisma.WorkLogCreateOrConnectWithoutWorkTemplateInput[]
  upsert?: Prisma.WorkLogUpsertWithWhereUniqueWithoutWorkTemplateInput | Prisma.WorkLogUpsertWithWhereUniqueWithoutWorkTemplateInput[]
  createMany?: Prisma.WorkLogCreateManyWorkTemplateInputEnvelope
  set?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  disconnect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  delete?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  connect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  update?: Prisma.WorkLogUpdateWithWhereUniqueWithoutWorkTemplateInput | Prisma.WorkLogUpdateWithWhereUniqueWithoutWorkTemplateInput[]
  updateMany?: Prisma.WorkLogUpdateManyWithWhereWithoutWorkTemplateInput | Prisma.WorkLogUpdateManyWithWhereWithoutWorkTemplateInput[]
  deleteMany?: Prisma.WorkLogScalarWhereInput | Prisma.WorkLogScalarWhereInput[]
}

export type WorkLogUncheckedUpdateManyWithoutWorkTemplateNestedInput = {
  create?: Prisma.XOR<Prisma.WorkLogCreateWithoutWorkTemplateInput, Prisma.WorkLogUncheckedCreateWithoutWorkTemplateInput> | Prisma.WorkLogCreateWithoutWorkTemplateInput[] | Prisma.WorkLogUncheckedCreateWithoutWorkTemplateInput[]
  connectOrCreate?: Prisma.WorkLogCreateOrConnectWithoutWorkTemplateInput | Prisma.WorkLogCreateOrConnectWithoutWorkTemplateInput[]
  upsert?: Prisma.WorkLogUpsertWithWhereUniqueWithoutWorkTemplateInput | Prisma.WorkLogUpsertWithWhereUniqueWithoutWorkTemplateInput[]
  createMany?: Prisma.WorkLogCreateManyWorkTemplateInputEnvelope
  set?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  disconnect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  delete?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  connect?: Prisma.WorkLogWhereUniqueInput | Prisma.WorkLogWhereUniqueInput[]
  update?: Prisma.WorkLogUpdateWithWhereUniqueWithoutWorkTemplateInput | Prisma.WorkLogUpdateWithWhereUniqueWithoutWorkTemplateInput[]
  updateMany?: Prisma.WorkLogUpdateManyWithWhereWithoutWorkTemplateInput | Prisma.WorkLogUpdateManyWithWhereWithoutWorkTemplateInput[]
  deleteMany?: Prisma.WorkLogScalarWhereInput | Prisma.WorkLogScalarWhereInput[]
}

export type WorkLogCreateWithoutEmployeeInput = {
  WorkDate?: Date | string | null
  LoginTime?: Date | string | null
  LogoutTime?: Date | string | null
  TotalWorkedHours?: runtime.Decimal | runtime.DecimalJsLike | number | string | null
  WorkTemplate?: Prisma.WorkTemplateCreateNestedOneWithoutWorkLogInput
}

export type WorkLogUncheckedCreateWithoutEmployeeInput = {
  LogID?: number
  TemplateID?: number | null
  WorkDate?: Date | string | null
  LoginTime?: Date | string | null
  LogoutTime?: Date | string | null
  TotalWorkedHours?: runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogCreateOrConnectWithoutEmployeeInput = {
  where: Prisma.WorkLogWhereUniqueInput
  create: Prisma.XOR<Prisma.WorkLogCreateWithoutEmployeeInput, Prisma.WorkLogUncheckedCreateWithoutEmployeeInput>
}

export type WorkLogCreateManyEmployeeInputEnvelope = {
  data: Prisma.WorkLogCreateManyEmployeeInput | Prisma.WorkLogCreateManyEmployeeInput[]
}

export type WorkLogUpsertWithWhereUniqueWithoutEmployeeInput = {
  where: Prisma.WorkLogWhereUniqueInput
  update: Prisma.XOR<Prisma.WorkLogUpdateWithoutEmployeeInput, Prisma.WorkLogUncheckedUpdateWithoutEmployeeInput>
  create: Prisma.XOR<Prisma.WorkLogCreateWithoutEmployeeInput, Prisma.WorkLogUncheckedCreateWithoutEmployeeInput>
}

export type WorkLogUpdateWithWhereUniqueWithoutEmployeeInput = {
  where: Prisma.WorkLogWhereUniqueInput
  data: Prisma.XOR<Prisma.WorkLogUpdateWithoutEmployeeInput, Prisma.WorkLogUncheckedUpdateWithoutEmployeeInput>
}

export type WorkLogUpdateManyWithWhereWithoutEmployeeInput = {
  where: Prisma.WorkLogScalarWhereInput
  data: Prisma.XOR<Prisma.WorkLogUpdateManyMutationInput, Prisma.WorkLogUncheckedUpdateManyWithoutEmployeeInput>
}

export type WorkLogScalarWhereInput = {
  AND?: Prisma.WorkLogScalarWhereInput | Prisma.WorkLogScalarWhereInput[]
  OR?: Prisma.WorkLogScalarWhereInput[]
  NOT?: Prisma.WorkLogScalarWhereInput | Prisma.WorkLogScalarWhereInput[]
  LogID?: Prisma.IntFilter<"WorkLog"> | number
  EmployeeID?: Prisma.IntFilter<"WorkLog"> | number
  TemplateID?: Prisma.IntNullableFilter<"WorkLog"> | number | null
  WorkDate?: Prisma.DateTimeNullableFilter<"WorkLog"> | Date | string | null
  LoginTime?: Prisma.DateTimeNullableFilter<"WorkLog"> | Date | string | null
  LogoutTime?: Prisma.DateTimeNullableFilter<"WorkLog"> | Date | string | null
  TotalWorkedHours?: Prisma.DecimalNullableFilter<"WorkLog"> | runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogCreateWithoutWorkTemplateInput = {
  WorkDate?: Date | string | null
  LoginTime?: Date | string | null
  LogoutTime?: Date | string | null
  TotalWorkedHours?: runtime.Decimal | runtime.DecimalJsLike | number | string | null
  Employee: Prisma.EmployeeCreateNestedOneWithoutWorkLogInput
}

export type WorkLogUncheckedCreateWithoutWorkTemplateInput = {
  LogID?: number
  EmployeeID: number
  WorkDate?: Date | string | null
  LoginTime?: Date | string | null
  LogoutTime?: Date | string | null
  TotalWorkedHours?: runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogCreateOrConnectWithoutWorkTemplateInput = {
  where: Prisma.WorkLogWhereUniqueInput
  create: Prisma.XOR<Prisma.WorkLogCreateWithoutWorkTemplateInput, Prisma.WorkLogUncheckedCreateWithoutWorkTemplateInput>
}

export type WorkLogCreateManyWorkTemplateInputEnvelope = {
  data: Prisma.WorkLogCreateManyWorkTemplateInput | Prisma.WorkLogCreateManyWorkTemplateInput[]
}

export type WorkLogUpsertWithWhereUniqueWithoutWorkTemplateInput = {
  where: Prisma.WorkLogWhereUniqueInput
  update: Prisma.XOR<Prisma.WorkLogUpdateWithoutWorkTemplateInput, Prisma.WorkLogUncheckedUpdateWithoutWorkTemplateInput>
  create: Prisma.XOR<Prisma.WorkLogCreateWithoutWorkTemplateInput, Prisma.WorkLogUncheckedCreateWithoutWorkTemplateInput>
}

export type WorkLogUpdateWithWhereUniqueWithoutWorkTemplateInput = {
  where: Prisma.WorkLogWhereUniqueInput
  data: Prisma.XOR<Prisma.WorkLogUpdateWithoutWorkTemplateInput, Prisma.WorkLogUncheckedUpdateWithoutWorkTemplateInput>
}

export type WorkLogUpdateManyWithWhereWithoutWorkTemplateInput = {
  where: Prisma.WorkLogScalarWhereInput
  data: Prisma.XOR<Prisma.WorkLogUpdateManyMutationInput, Prisma.WorkLogUncheckedUpdateManyWithoutWorkTemplateInput>
}

export type WorkLogCreateManyEmployeeInput = {
  TemplateID?: number | null
  WorkDate?: Date | string | null
  LoginTime?: Date | string | null
  LogoutTime?: Date | string | null
  TotalWorkedHours?: runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogUpdateWithoutEmployeeInput = {
  WorkDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LoginTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LogoutTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  TotalWorkedHours?: Prisma.NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null
  WorkTemplate?: Prisma.WorkTemplateUpdateOneWithoutWorkLogNestedInput
}

export type WorkLogUncheckedUpdateWithoutEmployeeInput = {
  LogID?: Prisma.IntFieldUpdateOperationsInput | number
  TemplateID?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  WorkDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LoginTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LogoutTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  TotalWorkedHours?: Prisma.NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogUncheckedUpdateManyWithoutEmployeeInput = {
  LogID?: Prisma.IntFieldUpdateOperationsInput | number
  TemplateID?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  WorkDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LoginTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LogoutTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  TotalWorkedHours?: Prisma.NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogCreateManyWorkTemplateInput = {
  EmployeeID: number
  WorkDate?: Date | string | null
  LoginTime?: Date | string | null
  LogoutTime?: Date | string | null
  TotalWorkedHours?: runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogUpdateWithoutWorkTemplateInput = {
  WorkDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LoginTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LogoutTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  TotalWorkedHours?: Prisma.NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null
  Employee?: Prisma.EmployeeUpdateOneRequiredWithoutWorkLogNestedInput
}

export type WorkLogUncheckedUpdateWithoutWorkTemplateInput = {
  LogID?: Prisma.IntFieldUpdateOperationsInput | number
  EmployeeID?: Prisma.IntFieldUpdateOperationsInput | number
  WorkDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LoginTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LogoutTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  TotalWorkedHours?: Prisma.NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null
}

export type WorkLogUncheckedUpdateManyWithoutWorkTemplateInput = {
  LogID?: Prisma.IntFieldUpdateOperationsInput | number
  EmployeeID?: Prisma.IntFieldUpdateOperationsInput | number
  WorkDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LoginTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  LogoutTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  TotalWorkedHours?: Prisma.NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null
}



export type WorkLogSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  LogID?: boolean
  EmployeeID?: boolean
  TemplateID?: boolean
  WorkDate?: boolean
  LoginTime?: boolean
  LogoutTime?: boolean
  TotalWorkedHours?: boolean
  Employee?: boolean | Prisma.EmployeeDefaultArgs<ExtArgs>
  WorkTemplate?: boolean | Prisma.WorkLog$WorkTemplateArgs<ExtArgs>
}, ExtArgs["result"]["workLog"]>



export type WorkLogSelectScalar = {
  LogID?: boolean
  EmployeeID?: boolean
  TemplateID?: boolean
  WorkDate?: boolean
  LoginTime?: boolean
  LogoutTime?: boolean
  TotalWorkedHours?: boolean
}

export type WorkLogOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"LogID" | "EmployeeID" | "TemplateID" | "WorkDate" | "LoginTime" | "LogoutTime" | "TotalWorkedHours", ExtArgs["result"]["workLog"]>
export type WorkLogInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  Employee?: boolean | Prisma.EmployeeDefaultArgs<ExtArgs>
  WorkTemplate?: boolean | Prisma.WorkLog$WorkTemplateArgs<ExtArgs>
}

export type $WorkLogPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "WorkLog"
  objects: {
    Employee: Prisma.$EmployeePayload<ExtArgs>
    WorkTemplate: Prisma.$WorkTemplatePayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    LogID: number
    EmployeeID: number
    TemplateID: number | null
    WorkDate: Date | null
    LoginTime: Date | null
    LogoutTime: Date | null
    TotalWorkedHours: runtime.Decimal | null
  }, ExtArgs["result"]["workLog"]>
  composites: {}
}

export type WorkLogGetPayload<S extends boolean | null | undefined | WorkLogDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$WorkLogPayload, S>

export type WorkLogCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<WorkLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: WorkLogCountAggregateInputType | true
  }

export interface WorkLogDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkLog'], meta: { name: 'WorkLog' } }
  /**
   * Find zero or one WorkLog that matches the filter.
   * @param {WorkLogFindUniqueArgs} args - Arguments to find a WorkLog
   * @example
   * // Get one WorkLog
   * const workLog = await prisma.workLog.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends WorkLogFindUniqueArgs>(args: Prisma.SelectSubset<T, WorkLogFindUniqueArgs<ExtArgs>>): Prisma.Prisma__WorkLogClient<runtime.Types.Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one WorkLog that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {WorkLogFindUniqueOrThrowArgs} args - Arguments to find a WorkLog
   * @example
   * // Get one WorkLog
   * const workLog = await prisma.workLog.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends WorkLogFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, WorkLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__WorkLogClient<runtime.Types.Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first WorkLog that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WorkLogFindFirstArgs} args - Arguments to find a WorkLog
   * @example
   * // Get one WorkLog
   * const workLog = await prisma.workLog.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends WorkLogFindFirstArgs>(args?: Prisma.SelectSubset<T, WorkLogFindFirstArgs<ExtArgs>>): Prisma.Prisma__WorkLogClient<runtime.Types.Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first WorkLog that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WorkLogFindFirstOrThrowArgs} args - Arguments to find a WorkLog
   * @example
   * // Get one WorkLog
   * const workLog = await prisma.workLog.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends WorkLogFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, WorkLogFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__WorkLogClient<runtime.Types.Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more WorkLogs that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WorkLogFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all WorkLogs
   * const workLogs = await prisma.workLog.findMany()
   * 
   * // Get first 10 WorkLogs
   * const workLogs = await prisma.workLog.findMany({ take: 10 })
   * 
   * // Only select the `LogID`
   * const workLogWithLogIDOnly = await prisma.workLog.findMany({ select: { LogID: true } })
   * 
   */
  findMany<T extends WorkLogFindManyArgs>(args?: Prisma.SelectSubset<T, WorkLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a WorkLog.
   * @param {WorkLogCreateArgs} args - Arguments to create a WorkLog.
   * @example
   * // Create one WorkLog
   * const WorkLog = await prisma.workLog.create({
   *   data: {
   *     // ... data to create a WorkLog
   *   }
   * })
   * 
   */
  create<T extends WorkLogCreateArgs>(args: Prisma.SelectSubset<T, WorkLogCreateArgs<ExtArgs>>): Prisma.Prisma__WorkLogClient<runtime.Types.Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many WorkLogs.
   * @param {WorkLogCreateManyArgs} args - Arguments to create many WorkLogs.
   * @example
   * // Create many WorkLogs
   * const workLog = await prisma.workLog.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends WorkLogCreateManyArgs>(args?: Prisma.SelectSubset<T, WorkLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Delete a WorkLog.
   * @param {WorkLogDeleteArgs} args - Arguments to delete one WorkLog.
   * @example
   * // Delete one WorkLog
   * const WorkLog = await prisma.workLog.delete({
   *   where: {
   *     // ... filter to delete one WorkLog
   *   }
   * })
   * 
   */
  delete<T extends WorkLogDeleteArgs>(args: Prisma.SelectSubset<T, WorkLogDeleteArgs<ExtArgs>>): Prisma.Prisma__WorkLogClient<runtime.Types.Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one WorkLog.
   * @param {WorkLogUpdateArgs} args - Arguments to update one WorkLog.
   * @example
   * // Update one WorkLog
   * const workLog = await prisma.workLog.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends WorkLogUpdateArgs>(args: Prisma.SelectSubset<T, WorkLogUpdateArgs<ExtArgs>>): Prisma.Prisma__WorkLogClient<runtime.Types.Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more WorkLogs.
   * @param {WorkLogDeleteManyArgs} args - Arguments to filter WorkLogs to delete.
   * @example
   * // Delete a few WorkLogs
   * const { count } = await prisma.workLog.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends WorkLogDeleteManyArgs>(args?: Prisma.SelectSubset<T, WorkLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more WorkLogs.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WorkLogUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many WorkLogs
   * const workLog = await prisma.workLog.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends WorkLogUpdateManyArgs>(args: Prisma.SelectSubset<T, WorkLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create or update one WorkLog.
   * @param {WorkLogUpsertArgs} args - Arguments to update or create a WorkLog.
   * @example
   * // Update or create a WorkLog
   * const workLog = await prisma.workLog.upsert({
   *   create: {
   *     // ... data to create a WorkLog
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the WorkLog we want to update
   *   }
   * })
   */
  upsert<T extends WorkLogUpsertArgs>(args: Prisma.SelectSubset<T, WorkLogUpsertArgs<ExtArgs>>): Prisma.Prisma__WorkLogClient<runtime.Types.Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of WorkLogs.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WorkLogCountArgs} args - Arguments to filter WorkLogs to count.
   * @example
   * // Count the number of WorkLogs
   * const count = await prisma.workLog.count({
   *   where: {
   *     // ... the filter for the WorkLogs we want to count
   *   }
   * })
  **/
  count<T extends WorkLogCountArgs>(
    args?: Prisma.Subset<T, WorkLogCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], WorkLogCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a WorkLog.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WorkLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends WorkLogAggregateArgs>(args: Prisma.Subset<T, WorkLogAggregateArgs>): Prisma.PrismaPromise<GetWorkLogAggregateType<T>>

  /**
   * Group by WorkLog.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {WorkLogGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends WorkLogGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: WorkLogGroupByArgs['orderBy'] }
      : { orderBy?: WorkLogGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, WorkLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the WorkLog model
 */
readonly fields: WorkLogFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for WorkLog.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__WorkLogClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  Employee<T extends Prisma.EmployeeDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.EmployeeDefaultArgs<ExtArgs>>): Prisma.Prisma__EmployeeClient<runtime.Types.Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  WorkTemplate<T extends Prisma.WorkLog$WorkTemplateArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.WorkLog$WorkTemplateArgs<ExtArgs>>): Prisma.Prisma__WorkTemplateClient<runtime.Types.Result.GetResult<Prisma.$WorkTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the WorkLog model
 */
export interface WorkLogFieldRefs {
  readonly LogID: Prisma.FieldRef<"WorkLog", 'Int'>
  readonly EmployeeID: Prisma.FieldRef<"WorkLog", 'Int'>
  readonly TemplateID: Prisma.FieldRef<"WorkLog", 'Int'>
  readonly WorkDate: Prisma.FieldRef<"WorkLog", 'DateTime'>
  readonly LoginTime: Prisma.FieldRef<"WorkLog", 'DateTime'>
  readonly LogoutTime: Prisma.FieldRef<"WorkLog", 'DateTime'>
  readonly TotalWorkedHours: Prisma.FieldRef<"WorkLog", 'Decimal'>
}
    

// Custom InputTypes
/**
 * WorkLog findUnique
 */
export type WorkLogFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the WorkLog
   */
  select?: Prisma.WorkLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the WorkLog
   */
  omit?: Prisma.WorkLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WorkLogInclude<ExtArgs> | null
  /**
   * Filter, which WorkLog to fetch.
   */
  where: Prisma.WorkLogWhereUniqueInput
}

/**
 * WorkLog findUniqueOrThrow
 */
export type WorkLogFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the WorkLog
   */
  select?: Prisma.WorkLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the WorkLog
   */
  omit?: Prisma.WorkLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WorkLogInclude<ExtArgs> | null
  /**
   * Filter, which WorkLog to fetch.
   */
  where: Prisma.WorkLogWhereUniqueInput
}

/**
 * WorkLog findFirst
 */
export type WorkLogFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the WorkLog
   */
  select?: Prisma.WorkLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the WorkLog
   */
  omit?: Prisma.WorkLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WorkLogInclude<ExtArgs> | null
  /**
   * Filter, which WorkLog to fetch.
   */
  where?: Prisma.WorkLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of WorkLogs to fetch.
   */
  orderBy?: Prisma.WorkLogOrderByWithRelationInput | Prisma.WorkLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for WorkLogs.
   */
  cursor?: Prisma.WorkLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` WorkLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` WorkLogs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of WorkLogs.
   */
  distinct?: Prisma.WorkLogScalarFieldEnum | Prisma.WorkLogScalarFieldEnum[]
}

/**
 * WorkLog findFirstOrThrow
 */
export type WorkLogFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the WorkLog
   */
  select?: Prisma.WorkLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the WorkLog
   */
  omit?: Prisma.WorkLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WorkLogInclude<ExtArgs> | null
  /**
   * Filter, which WorkLog to fetch.
   */
  where?: Prisma.WorkLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of WorkLogs to fetch.
   */
  orderBy?: Prisma.WorkLogOrderByWithRelationInput | Prisma.WorkLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for WorkLogs.
   */
  cursor?: Prisma.WorkLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` WorkLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` WorkLogs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of WorkLogs.
   */
  distinct?: Prisma.WorkLogScalarFieldEnum | Prisma.WorkLogScalarFieldEnum[]
}

/**
 * WorkLog findMany
 */
export type WorkLogFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the WorkLog
   */
  select?: Prisma.WorkLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the WorkLog
   */
  omit?: Prisma.WorkLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WorkLogInclude<ExtArgs> | null
  /**
   * Filter, which WorkLogs to fetch.
   */
  where?: Prisma.WorkLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of WorkLogs to fetch.
   */
  orderBy?: Prisma.WorkLogOrderByWithRelationInput | Prisma.WorkLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing WorkLogs.
   */
  cursor?: Prisma.WorkLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` WorkLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` WorkLogs.
   */
  skip?: number
  distinct?: Prisma.WorkLogScalarFieldEnum | Prisma.WorkLogScalarFieldEnum[]
}

/**
 * WorkLog create
 */
export type WorkLogCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the WorkLog
   */
  select?: Prisma.WorkLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the WorkLog
   */
  omit?: Prisma.WorkLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WorkLogInclude<ExtArgs> | null
  /**
   * The data needed to create a WorkLog.
   */
  data: Prisma.XOR<Prisma.WorkLogCreateInput, Prisma.WorkLogUncheckedCreateInput>
}

/**
 * WorkLog createMany
 */
export type WorkLogCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many WorkLogs.
   */
  data: Prisma.WorkLogCreateManyInput | Prisma.WorkLogCreateManyInput[]
}

/**
 * WorkLog update
 */
export type WorkLogUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the WorkLog
   */
  select?: Prisma.WorkLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the WorkLog
   */
  omit?: Prisma.WorkLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WorkLogInclude<ExtArgs> | null
  /**
   * The data needed to update a WorkLog.
   */
  data: Prisma.XOR<Prisma.WorkLogUpdateInput, Prisma.WorkLogUncheckedUpdateInput>
  /**
   * Choose, which WorkLog to update.
   */
  where: Prisma.WorkLogWhereUniqueInput
}

/**
 * WorkLog updateMany
 */
export type WorkLogUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update WorkLogs.
   */
  data: Prisma.XOR<Prisma.WorkLogUpdateManyMutationInput, Prisma.WorkLogUncheckedUpdateManyInput>
  /**
   * Filter which WorkLogs to update
   */
  where?: Prisma.WorkLogWhereInput
  /**
   * Limit how many WorkLogs to update.
   */
  limit?: number
}

/**
 * WorkLog upsert
 */
export type WorkLogUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the WorkLog
   */
  select?: Prisma.WorkLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the WorkLog
   */
  omit?: Prisma.WorkLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WorkLogInclude<ExtArgs> | null
  /**
   * The filter to search for the WorkLog to update in case it exists.
   */
  where: Prisma.WorkLogWhereUniqueInput
  /**
   * In case the WorkLog found by the `where` argument doesn't exist, create a new WorkLog with this data.
   */
  create: Prisma.XOR<Prisma.WorkLogCreateInput, Prisma.WorkLogUncheckedCreateInput>
  /**
   * In case the WorkLog was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.WorkLogUpdateInput, Prisma.WorkLogUncheckedUpdateInput>
}

/**
 * WorkLog delete
 */
export type WorkLogDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the WorkLog
   */
  select?: Prisma.WorkLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the WorkLog
   */
  omit?: Prisma.WorkLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WorkLogInclude<ExtArgs> | null
  /**
   * Filter which WorkLog to delete.
   */
  where: Prisma.WorkLogWhereUniqueInput
}

/**
 * WorkLog deleteMany
 */
export type WorkLogDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which WorkLogs to delete
   */
  where?: Prisma.WorkLogWhereInput
  /**
   * Limit how many WorkLogs to delete.
   */
  limit?: number
}

/**
 * WorkLog.WorkTemplate
 */
export type WorkLog$WorkTemplateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the WorkTemplate
   */
  select?: Prisma.WorkTemplateSelect<ExtArgs> | null
  /**
   * Omit specific fields from the WorkTemplate
   */
  omit?: Prisma.WorkTemplateOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WorkTemplateInclude<ExtArgs> | null
  where?: Prisma.WorkTemplateWhereInput
}

/**
 * WorkLog without action
 */
export type WorkLogDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the WorkLog
   */
  select?: Prisma.WorkLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the WorkLog
   */
  omit?: Prisma.WorkLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.WorkLogInclude<ExtArgs> | null
}
